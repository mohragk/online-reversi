<html>
    <head>
        <title>Reversi</title>
        <style>

            #main {
                width: 600px;
                margin: 0 auto;
                margin-top: 48px;
            }

            #grid_canvas {
                margin: 24px 0;
            }

            #end_turn_button {
                background-color: blue;
                border: none;
                color: white;
                padding: 24px 48px;
                text-align: center;
                display: inline-block;
                font-size: 36px;
                width: 100%;
            }

            #end_turn_button:disabled,
            #end_turn_button[disabled]{
                background-color: #cccccc;
                color: #666666;
            }

            .disable-dbl-tap-zoom {
                touch-action: manipulation;
            }
        </style>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    </head>
    <body>
        <script src="/socket.io/socket.io.js"></script>
        <script
            src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
            integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs="
            crossorigin="anonymous">
        </script>

        <div id="main">
            <div id="player_data">Waiting for other player</div>
            <div id="player_score"></div>
            <canvas id="grid_canvas" class="disable-dbl-tap-zoom" width="600" height="600"></canvas>
            <button id="end_turn_button">End turn</button>
        </div>

    </body>
      
    


    <script>
        let socket
        let player_number
        let your_turn = false
        let cell_size_pixels = 48
        let mouse_position
        let player_score
        const game_state_poll_rate_hz = 5

        const BUTTON_STATES_TEXT = {
            WAIT: 'Wait turn',
            ACTIVE: 'End turn'
        }

        function drawCircle(context, x, y, radius) {
            context.beginPath();
            
            // Draws a circle of radius 20 at the coordinates 100,100 on the canvas
            const new_x = x + (0.5 * radius)
            const new_y = y + (0.5 * radius)
            context.arc(new_x, new_y, 0.5*radius, 0, Math.PI*2, true);
            context.closePath();
            context.fill();
        } 

        

        jQuery(document).ready(async function($) {
            function isDoubleTap() {
                let is_double_tap = false
                const now = new Date().getTime()
                let time_since = now - latest_tap_time
                const double_tap_time = 260
                if (time_since >= 0 && time_since < double_tap_time) {
                    is_double_tap = true
                }
                latest_tap_time = new Date().getTime()

                return is_double_tap
            }

            socket = await io.connect('')

            
            var canvas = document.getElementById('grid_canvas');
            var ctx = canvas.getContext('2d');
            
            
            canvas.addEventListener('mousemove', function(e) {
                mouse_position = getMousePos(canvas, e);
            }, false);
            
           
            let latest_tap_time = new Date().getTime()
            canvas.addEventListener("click", function(e) {
                // Convert mouse coords to grid coords
                const col = Math.floor(mouse_position.x / cell_size_pixels)
                const row = Math.floor(mouse_position.y / cell_size_pixels)

                if (e.button === 0) {
                    socket.emit('add_or_flip_coin', {row, col, player_number})
                }
                
                if ( isDoubleTap() ) {
                    socket.emit('remove_coin', {row, col})
                }
            }, false);


            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault()

                // Convert mouse coords to grid coords
                const col = Math.floor(mouse_position.x / cell_size_pixels)
                const row = Math.floor(mouse_position.y / cell_size_pixels)
                socket.emit('remove_coin', {row, col})
            })

            window.addEventListener('keypress', function(e) {
                //S or E
                if (e.keyCode === 115 || e.keyCode === 101 ) {
                    socket.emit('switch_to_other_player', player_number)
                }
            })

            function getMousePos(canvas, e) {
                var rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            $('#end_turn_button').click(function(e) {
                e.preventDefault()
                socket.emit('switch_to_other_player', player_number)
            })
            .prop('disabled', true) // hide at start
            .text(BUTTON_STATES_TEXT.WAIT)

            // SOCKET STUFF
            
            socket.on('waiting', (msg)=> {
               // handle waiting, i guess
            })

            socket.on('game_ended', function(msg) {
                var canvas_w = canvas.width;
                var canvas_h = canvas.height;
                ctx.clearRect(0,0, canvas_w, canvas_h)

                // draw border
                ctx.strokeStyle = 'black'
                ctx.lineWidth = 4;
                ctx.strokeRect(0,0, canvas_w, canvas_h )

                ctx.font = "32px Arial"
                ctx.textAlign = "center"
                ctx.fillStyle = 'black'
                ctx.fillText("No other player available", canvas_w/2 , canvas_h/2);

                player_score = 0;
                $('#end_turn_button')
                .prop('disabled', true)
                .text(BUTTON_STATES_TEXT.WAIT)
            })

            socket.on('player_number', number => {
                player_number = number;
                const player_data = $('#player_data');
                
                
                let player_color
                if (player_number == 1) {
                    player_color = `RED`
                }
                else {
                   player_color = `GREEN`
                }
                let message = `You're the ${player_color} player`


                player_data.empty().append (
                    $('<h4>').text(message)
                )
            })

            setInterval( () => { 
                socket.emit('request_update')
            }, 1000/game_state_poll_rate_hz )
            

            socket.on('game_update', (game_state) => {

                const player_score_div = $('#player_score').text(`Score: ${player_score}` )

                if (game_state !== null) {
                    var canvas_w = canvas.width;
                    var canvas_h = canvas.height;
                    ctx.clearRect(0,0, canvas_w, canvas_h)

                    // reset
                    player_score = 0
                    
                    // update and draw grid
                    const { grid, grid_dim } = game_state
                    cell_size_pixels = canvas_h / grid_dim
                    for (let row = 0 ; row < grid_dim; row++) {
                        for (let col = 0 ; col < grid_dim; col++) {
                            const margin = 8
                            const half_margin = margin / 2
                            let x = col * cell_size_pixels + (0.5 * half_margin)
                            let y = row * cell_size_pixels + (0.5 * half_margin)
                            
                            const cell_value = grid[row * grid_dim + col]
                            if (cell_value === player_number) player_score++
                            ctx.fillStyle = 'rgb(37, 37, 37)'
                            ctx.fillRect(x, y, cell_size_pixels - half_margin, cell_size_pixels - half_margin)
                            


                            x += 0.5 * half_margin
                            y += 0.5 * half_margin
                            if (cell_value == 1) {

                                ctx.fillStyle = 'red'
                                drawCircle(ctx, x, y, cell_size_pixels - margin)
                            }
                            else if (cell_value == 2) {
                                ctx.fillStyle = 'green' 
                                drawCircle(ctx, x, y, cell_size_pixels - margin)
                            }
                        }
                    }
                    
                    your_turn = (game_state.current_player_number === player_number)
                    
                    $('#end_turn_button')
                    .prop('disabled', !your_turn)

                    
                    $('#end_turn_button')
                    .text(BUTTON_STATES_TEXT.WAIT)

                    if (your_turn) {
                        // draw border
                        ctx.strokeStyle = player_number === 1 ? 'red' : 'green'
                        ctx.lineWidth = 8 * 4;
                        ctx.strokeRect(0,0, canvas_w, canvas_h )

                        $('#end_turn_button')
                        .text(BUTTON_STATES_TEXT.ACTIVE)

                    }
                }
            })

           

           
        })
    </script>
</html>